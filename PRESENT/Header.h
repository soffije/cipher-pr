#pragma once
using namespace std;

class PRESENT_KEY
{
private:
	int key[80];	//начальный ключ 80 бит
	int round_key[80];	//для генерации раундовых ключей
	int k[32][80]; 	//раундовый набор ключей
	int s_box[16][4];	//sbox
	int fin;	
	int num;

public:
	int sbox[16][4];
	int k_share[32][80];	//для обмена круглыми ключами
	PRESENT_KEY()	//инициализируем ключи сразу после создания объекта
	{
		int sbox1[16][4] = { {1,1,0,0}, {0,1,0,1}, {0,1,1,0}, {1,0,1,1}, {1,0,0,1}, {0,0,0,0}, {1,0,1,0}, {1,1,0,1}, {0,0,1,1}, {1,1,1,0}, {1,1,1,1}, {1,0,0,0}, {0,1,0,0}, {0,1,1,1}, {0,0,0,1}, {0,0,1,0} };
		int sbox[16][4] = { {1,1,0,0}, {0,1,0,1}, {0,1,1,0}, {1,0,1,1}, {1,0,0,1}, {0,0,0,0}, {1,0,1,0}, {1,1,0,1}, {0,0,1,1}, {1,1,1,0}, {1,1,1,1}, {1,0,0,0}, {0,1,0,0}, {0,1,1,1}, {0,0,0,1}, {0,0,1,0} };

		for (int i = 0; i < 80; ++i)		//начальная генерация ключа
		{
			key[i] = rand() % 2;
			round_key[i] = key[i];
			k[0][i] = key[i];		//потому что ключ первого ранунда такой же
		}
		for (int j = 1; j < 32; ++j)		//обновляем ключ
		{
			for (int i = 0; i < 80; ++i)		//сдвиг влево
			{
				k[j][i] = round_key[(i + 19) % 80];
			}

			fin = k[j][76] * 1 + k[j][77] * 2 + k[j][78] * 4 + k[j][79] * 8;		//перестановка sbox
			for (int i = 76; i < 80; ++i)
			{
				k[j][i] = sbox1[fin][i - 76];
			}
			num = j;

			while (num > 0)		//счетчик XOR
			{
				fin = 15;
				k[j][fin] = k[j][fin] ^ (num % 2); //побитовое XOR + счетчик
				fin++;
				num /= 2;
			}

			for (int i = 0; i < 80; ++i)	//сохраняем ключ до обновления
			{
				round_key[i] = k[j][i];
			}
		}
	}
	void key_SHARE()	//для обмена ключами
	{
		for (int j = 0; j < 32; ++j)
		{
			for (int i = 0; i < 80; ++i)
			{
				k_share[j][i] = k[j][i];
			}
		}
	}
};
